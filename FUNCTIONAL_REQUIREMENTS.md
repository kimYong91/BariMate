# 기능 요구사항 명세서

## 1. 사용자 인증 (Authentication)

### FR-001: 회원가입
-   **개요:** 사용자가 서비스 이용을 위해 계정을 생성합니다.
-   **상세 설명:**
    -   **선행 조건:** -
    -   **입력:** 아이디(이메일 형식), 비밀번호, 비밀번호 확인, 닉네임
    -   **처리 과정:**
        1.  입력 값 유효성 검사 (아이디 형식, 비밀번호 강도, 닉네임 중복 등)
        2.  비밀번호 암호화
        3.  사용자 정보 DB 저장
    -   **출력/결과:** 회원가입 성공 메시지, 로그인 페이지로 이동
    -   **후행 조건:** 사용자 계정 생성됨, 로그인 가능 상태
-   **비고:** 소셜 로그인 기능 추후 고려

### FR-002: 로그인
-   **개요:** 등록된 사용자가 서비스에 접근하고, 애플리케이션을 종료하거나 재시작한 후에도 로그인 상태가 유지되도록 합니다.
-   **상세 설명:**
    -   **선행 조건:** 회원가입 완료
    -   **입력:** 아이디(이메일), 비밀번호
    -   **처리 과정:**
        1.  아이디, 비밀번호 일치 여부 확인 (암호화된 비밀번호 비교).
        2.  로그인 성공 시, 서버는 Access Token과 Refresh Token을 발급합니다.
        3.  Access Token은 API 요청 시 인증에 사용되며, 비교적 짧은 만료 시간을 가집니다.
        4.  Refresh Token은 Access Token이 만료되었을 때 새로운 Access Token을 발급받기 위해 사용되며, 더 긴 만료 시간을 가집니다.
        5.  발급된 토큰은 클라이언트(웹 브라우저)에 안전하게 저장됩니다.
    -   **출력/결과:** 로그인 성공 메시지, 메인 페이지로 이동, Access Token, Refresh Token.
    -   **후행 조건:** 사용자 로그인 상태, 클라이언트에 토큰 저장됨. 앱 재시작 시 토큰 유효성 검사를 통해 자동 로그인 가능 상태.
-   **비고:**
    -   Access Token 만료 시간 정책 (예: 15분 ~ 1시간).
    -   Refresh Token 만료 시간 정책 (예: 7일 ~ 30일).
    -   토큰 저장 방식: 클라이언트는 토큰을 안전하게 저장해야 합니다 (예: 웹의 경우 HttpOnly 쿠키 사용 권장, 또는 `localStorage` 사용 시 XSS 공격 방지책 고려).
    -   앱/웹 재시작 시, 저장된 Refresh Token을 사용하여 자동으로 Access Token을 갱신하고 로그인 상태를 복원하는 로직이 필요합니다.
    -   Refresh Token을 이용한 Access Token 재발급을 위한 API 엔드포인트가 백엔드에 필요합니다.
    -   로그아웃 시 클라이언트의 토큰 제거 및 서버 측의 Refresh Token 무효화 처리 (필요시).

### FR-003: 로그아웃
-   **개요:** 사용자가 서비스 이용을 종료합니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태
    -   **입력:** 로그아웃 요청
    -   **처리 과정:** 클라이언트 측 토큰 제거, (필요시) 서버 측 Refresh Token 무효화
    -   **출력/결과:** 로그아웃 성공, 로그인 페이지로 이동
    -   **후행 조건:** 사용자 로그아웃 상태
-   **비고:** -

## 2. 메모 및 용어 정리

### FR-004: 텍스트 메모 입력
-   **개요:** 사용자가 기술 용어 학습을 위한 내용을 텍스트로 입력하고 저장하며, AI 분석을 위한 준비를 합니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태
    -   **입력:** 메모 제목, 메모 내용 (**일반 텍스트**), 관련 주제(태그) 선택/입력, 카테고리 선택, 중요도 표시
    -   **처리 과정:**
        1.  입력 값 유효성 검사
        2.  메모 정보 DB 저장 (사용자 ID와 연결, 자동 저장 기능 포함)
        3.  (사용자 액션) 본문 내용에서 AI로 용어 추출 버튼 클릭 시 FR-006으로 연계
    -   **출력/결과:** 메모 저장 (자동), (버튼 클릭 시) 추출된 용어 정보와 함께 FR-006으로 전달
    -   **후행 조건:** 새로운 메모 생성됨, 또는 AI 분석을 위해 내용 전달 준비 완료
-   **비고:** 긴 텍스트에서 용어 추출 기능(FR-006 연동) 제공. 카테고리 및 중요도는 별도 FR에서 상세 정의. **사용자 입력은 일반 텍스트를 기본으로 하며, AI가 생성하거나 사용자가 편집하는 최종 설명 콘텐츠는 마크다운 형식으로 저장 및 표시될 수 있음.**

### FR-005: (신규) 카테고리 관리
-   **개요:** 사용자가 메모 분류를 위해 자신만의 카테고리를 생성, 수정, 삭제합니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태
    -   **입력:** 카테고리명, (수정/삭제 시) 대상 카테고리 ID
    -   **처리 과정:**
        1.  (생성 시) 카테고리명 유효성 검사, 중복 검사 (사용자 범위 내).
        2.  카테고리 정보 DB CRUD 작업 (사용자 ID와 연결).
    -   **출력/결과:** 작업 성공/실패 메시지, 업데이트된 카테고리 목록.
    -   **후행 조건:** 사용자의 카테고리 목록 변경됨.
-   **비고:** 사용자 프로필/설정 페이지 내에서 관리 인터페이스 제공 (`PAGE_LIST.md` 참고).

### FR-006: AI 기반 용어 자동 정리 및 설명
-   **개요:** 사용자가 입력한 메모 텍스트에서 추출된 용어들을 AI가 설명하고, 사용자는 이를 검토 및 저장합니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태, 정리할 텍스트 메모(FR-004)에서 용어 추출이 완료된 상태 (또는 사용자가 직접 용어 입력).
    -   **입력:** FR-004에서 추출/선택된 용어 목록 (또는 사용자 직접 입력 용어), (필요시) 원본 텍스트의 전체 또는 일부 맥락, 설명 요청.
    -   **처리 과정:**
        1.  선택된 용어들과 (필요시) 맥락 정보를 AI 모델(Google Gemini API, `backend/prompts.py` 활용)에 전달.
        2.  AI 모델이 각 용어에 대한 설명을 생성
        3.  생성된 용어와 설명을 사용자에게 목록 또는 표 형태로 표시
        4.  사용자가 생성된 내용을 편집/수정 가능하도록 인터페이스 제공 (예: 설명 수정, 용어 삭제/추가, 개인 이미지/자료 첨부 기능).
        5.  최종 정리 내용을 저장 (FR-007과 연계).
    -   **출력/결과:** 용어 및 AI 생성 설명 목록, 편집 인터페이스.
    -   **후행 조건:** AI에 의해 생성되고 사용자가 검토한 용어 정리 내용 확보.
-   **비고:** AI 모델 프롬프트 최적화 필요. 설명 품질 관리 방안 필요. 추가 설명 요청 기능 (유료화 고려, `PAGE_LIST.md` 참고)은 별도 FR로 구체화 가능. **AI 생성 설명의 가독성을 위해 구조화된 텍스트(예: 마크다운) 형식 활용 고려.**

### FR-007: 개인별 용어/설명 저장 및 재열람
-   **개요:** 사용자가 직접 작성하거나 AI가 생성해준 용어 정리 내용을 개인 공간에 저장하고 언제든지 다시 볼 수 있습니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태, 저장할 용어 정리 내용 존재 (FR-004, FR-006의 결과).
    -   **입력:** 저장할 용어 정리 데이터 (제목, 내용, 주제/태그, 카테고리, 중요도, 원본 메모 링크, 텍스트 및 설명에 대한 임베딩 벡터 등).
    -   **처리 과정:**
        1.  용어 정리 데이터 DB 저장 (사용자 ID와 연결, PostgreSQL 및 pgvector 활용).
    -   **출력/결과:** 저장 성공 메시지, 용어 목록 또는 상세 보기 화면으로 이동
    -   **후행 조건:** 사용자의 개인 용어 사전에 새로운 항목 추가됨.
-   **비고:** 즐겨찾기 기능 고려. 중요도 표시는 FR-XXX (신규)에서 상세 정의.

### FR-007-1: (신규) 중요도 표시 기능
-   **개요:** 사용자가 메모 또는 저장된 용어/설명에 중요도를 표시하고, 이를 기준으로 정렬하거나 필터링할 수 있습니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태, 중요도를 표시할 메모 또는 용어/설명 존재.
    -   **입력:** 대상 아이템(메모/용어) ID, 중요도 값 (예: 별점 1~5, 또는 단순 중요/보통 플래그).
    -   **처리 과정:**
        1.  DB에 해당 아이템의 중요도 정보 업데이트.
    -   **출력/결과:** 중요도 표시 성공 메시지.
    -   **후행 조건:** 해당 아이템의 중요도 변경됨.
-   **비고:** 목록 조회 시 중요도순 정렬 옵션 제공 (`PAGE_LIST.md` 참고).

## 3. 검색 및 공유

### FR-008: 용어 검색 (개인/공유)
-   **개요:** 사용자가 자신이 저장한 용어 또는 다른 사용자가 공유한 용어를 검색합니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태
    -   **입력:** 검색 키워드, 검색 범위 (내 용어, 공유된 용어)
    -   **처리 과정:**
        1.  선택된 범위에 따라 DB에서 키워드와 일치하거나 관련된 용어 검색 (초기에는 텍스트 기반 `LIKE` 검색, 추후 임베딩 기반 의미 검색으로 확장 고려 - PostgreSQL, pgvector 활용).
        2.  검색 결과 정렬 (관련도순, 최신순 등)
    -   **출력/결과:** 검색 결과 목록 (용어, 간략한 설명, 출처 등)
    -   **후행 조건:** -
-   **비고:** 검색 정확도, 다양한 검색 옵션(예: 태그 기반 검색) 고려

### FR-009: 공유된 용어 설명 열람
-   **개요:** 다른 사용자가 공개적으로 공유한 용어 정리 내용을 열람합니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태 (또는 비로그인 사용자도 일부 열람 가능하도록 정책 결정 필요)
    -   **입력:** 열람할 용어 선택 (예: 인기 용어, 최신 공유 용어 목록에서 선택 또는 검색 결과에서 선택)
    -   **처리 과정:** 선택된 용어의 상세 정보 DB에서 조회 (작성자 정보 포함).
    -   **출력/결과:** 선택된 용어의 상세 설명 페이지 (작성자, 작성일, 추천수, 댓글 등 포함 가능)
    -   **후행 조건:** -
-   **비고:** 추천/비추천, 댓글 기능 고려, 공유 정책 정의 필요 (예: 저작권, 내용 검토). 공유 용어에 대한 소유권 및 편집 권한 정책 명확화 필요.

### FR-009-1: (신규) AI 기반 링크 추천 및 수동 연결
-   **개요:** 사용자가 현재 보고 있는 메모나 용어 설명과 관련성이 높은 다른 저장된 메모/용어를 AI가 추천하고, 사용자는 이를 선택하여 수동으로 연결할 수 있습니다.
-   **상세 설명:**
    -   **선행 조건:** 로그인 상태, 임베딩 벡터가 저장된 메모/용어가 하나 이상 존재.
    -   **입력 (추천 요청 시):** 현재 보고 있는 메모/용어 ID.
    -   **처리 과정 (추천):**
        1.  현재 아이템의 임베딩 벡터를 DB에서 조회.
        2.  DB에 저장된 다른 모든 메모/용어들의 임베딩 벡터들과 유사도 계산 (예: 코사인 유사도, pgvector 활용).
        3.  유사도가 높은 상위 N개의 메모/용어 목록 반환.
    -   **출력 (추천):** 관련 메모/용어 추천 목록 (제목, 간략 내용 등).
    -   **입력 (수동 연결 시):** 소스 메모/용어 ID, 타겟 메모/용어 ID.
    -   **처리 과정 (수동 연결):**
        1.  두 아이템 간의 연결 관계를 DB에 저장 (별도 `Links` 테이블 또는 유사 구조 활용).
    -   **출력 (수동 연결):** 연결 성공 메시지.
    -   **후행 조건:** 아이템 간 링크 생성됨, 링크된 정보는 상세 조회 시 표시 가능.
-   **비고:** 추천 알고리즘 및 UI/UX 상세 설계 필요. `DEVELOPMENT_PLAN.md` 페이즈 2 내용 참고.

## 4. 기타

### FR-010: PWA 지원 (추후)
-   **개요:** 웹 애플리케이션을 PWA(Progressive Web App) 형태로 제공하여 앱 설치 없이 모바일 홈 화면 추가 및 오프라인 기능 등을 지원합니다.
-   **상세 설명:** (추후 구체화)
-   **비고:** 초기 버전에서는 웹 반응형으로 우선 개발 후 PWA 전환 고려 